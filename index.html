<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Mars : 简洁实用的服务调用框架" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Mars</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/netcomm/mars">View on GitHub</a>

          <h1 id="project_title">Mars</h1>
          <h2 id="project_tagline">简洁实用的服务调用框架</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/netcomm/mars/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/netcomm/mars/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h2>mars概述</h2>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Mars：火星)Mars定位在实用、透明化的轻量级远过程调用(RPC)。设计功能包括：</p>
					<ul>
						<li>像调用本地方法一样透明的调用远程方法，只需通过Spring简单配置就可完成，对应用或业务代码是完全透明的。</li>
						<li>服务提供者的自动注册与发现，服务调用方不必事先配置服务提供方地址，注册中心能自动分发新增或删除的服务提供者信息。</li>
						<li>提供服务的负载均衡、容错、HA等机制。</li>
						<li>能对每笔服务调用的执行时间、成功与否等关键指标进行监控，以达到可运维。</li>
						<li>提供高性能的服务调用。</li>
						<li>服务提供者、消费者只支持java语言。</li>
					</ul>

			<h2>mars功能</h2>
        	<strong><li>应用或业务代码可以透明的调用远端服务</li></strong>
        	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过java的动态代理等机制，就可以让一个远端服务提供者‘隐藏’在一个接口类后面。同时，使用spring2以上版本提供的自定义标签功能，
        	用户就可以在现有spring配置文件中方便的使用Mars。通过这些方法，就可以让用户的代码没有任何改动，就能调用到远程的服务了。
        	<strong><li>提供服务的注册中心</li></strong>
        	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;采用zookeeper作为注册中心，服务提供者可以把服务发布到zookeeper上，同时zookeeper会把最新的服务提供者推给相关的消费者。
					消费者通过这种机制可以自动的新增、删除服务提供者。
					<strong><li>提供服务的负载均衡、容错、HA</li></strong>
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;服务消费者可以把同一个服务接口的多个提供者做一个集群，并提供灵活的负载均衡策略，如RoundRobin(轮循每个服务提供者)。
					同时提供集群的容错策略，如提供Failover Cluster(失败自动切换，当出现失败，重试其它服务器)。同时也可以提供HA机制，
					如Master-Slave方式，只有当Master失效后才向Slave发送服务请求。
					<strong><li>监控服务的调用情况</li></strong>
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系统是否可运维对生产系统来说是非常重要的一个方面，Mars可以记录每次服务调用的时间、次数，这样就可以捕获调用异常，
					如服务调用在某个时间段比较慢。
					<strong><li>提供高效、稳定的通讯功能</li></strong>
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;服务消费者和提供者之间采用Mars内部实现的一套自定义通讯框架，在保证性能的前提下提供心跳、失败重连等机制，
					以应对各种复杂的网络环境。
					
			<h2>mars设计</h2>
					<strong><li>软件架构</li></strong>
						<img src="images/struct.png">
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;服务请求Client和服务提供Server端它们之间采用TCP通讯。Mars的架构设计分成以下几层，我们按图从下往上依次介绍：
						<li>Transport：传输层。它定义数据的传输方式，目前采用Mars自己的传输格式，这一层的主要功能包括：心跳、重连、报文的拆/组包等。</li>
						<li>Protocol：协议层，定义数据的传输格式，这一层的主要功能包括提供Json、Xml、Protobuf、java序列化bytes流等协议的编、解码。
						(目前采用编写glowworm这个开源序列化包)</li>
						<strong><li>Filter：过滤层，它在服务消费方或提供方的职能是不一样的。</li></strong>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、	服务消费方：主要提供监控的Filter。<br>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、	服务提供方：主要提供服务调用权限控制等Filter。
						<strong><li>Cluster/ LoadBalance：集群层，这一层主要功能是为服务消费方提供集群等功能。</li></strong>
						<strong><li>服务接口的Proxy和服务的Wrapper：</li></strong>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、服务接口的Proxy：它作用在服务调用Client端，它采用动态代理机制并通过Spring注入到服务请求方的业务代码中，充当一个接口的现实。
						这样业务代码在使用的时候根本不用知道它调用的是本地接口实现还是远程服务。
						<br>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、服务接口的Wrapper：它作用在服务提供者Server端，它的作用是把从协议层来的服务请求，转换成对具体服务实现类的调用。
						<li>用户的业务代码和服务具体实现类</li>
					<strong><li>软件架构</li></strong>
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mars的领域模型非常直白：应用代码发起的任何远程调用都会被mars客户端封装成一个Request实例，序列化传给服务器端。mars服务器端收到客户端请求处理完后，
					把处理结果序列化之后返回给调用方。mars的所有设计都是为了完成这一转化。
					<strong><li>物理部署架构设计</li></strong>
					<img src="images/deploy.png">
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面是一个生产环境的部署示意图，某一个服务有多个提供者部署在不同的机器上，这样服务消费方可以通过注册中心，
					自动的新增、删除服务提供者，当服务能力不够的时候，可以方便的新增服务提供方的数量。
			
			<h2>mars实现</h2>
				<strong><li>服务暴露过程</li></strong>
					<img src="images/serviceexport.png">
				<strong><li>服务消费过程</li></strong>
					<img src="images/serviceref.png">
				<strong><li>模块包结构</li></strong>
					*registry：服务注册模块。<br>
					*request：服务请求模块，包括集群、负载均衡等。<br>
					*proxy：创建代理模块。<br>
					*serviceexporter：服务暴露模块。<br>
					*spring：spring自定义标签模块。<br>
					*transport：传输层模块。<br>
				
			<h2>mars通讯层实现</h2>
				mars的通讯层主要是参考ActiveMQ的通讯层实现的。
				<img src="images/communication.png">
					<h3>client设计</h3>
					client的设计采用职责链的方式，通过定义接口类Transport、TransportListener、TransportFilter，把socket通讯相关的失败重连、心跳处理、请求响应匹配等基本功能“串”起来，以完成client端需要完成的功能。
					<h3>Server设计</h3>
					Server端处理相对简单，它解析发过来的请求，并通过线程池来执行具体业务处理，超过线程池无法处理的请求将直接丢弃。
					<h3>Message格式(报文头(12 bytes) + 报文体)</h3>
						<h4>报文头格式</h4>
						<table>
							<tr>
								<th>类型</th>
								<th>长度(byte)</th>
								<th>位置</th>
								<th>描述</th>
							</tr>
							<tr><td>int</td><td>4</td><td>0-3</td><td>报文长度</td></tr>
							<tr><td>byte</td><td>2</td><td>4-5</td><td>magic验证功能</td></tr>
							<tr><td>byte</td><td>1</td><td>6</td><td>压缩标识，0=未压缩，1=压缩</td></tr>
						</table>
						<h4>报文体格式</h4>
						<table>
							<tr>
								<th>类型</th>
								<th>长度(byte)</th>
								<th>位置</th>
								<th>描述</th>
							</tr>
							<tr><td>long</td><td>8</td><td>0-7</td><td>消息id</td></tr>
							<tr><td>byte</td><td>1</td><td>8</td><td>报文类型</td></tr>
							<tr><td>byte</td><td>1</td><td>9</td><td>该报文是否需要回复</td></tr>
							<tr><td>int</td><td>4</td><td>10-13</td><td>报文具体内容长度</td></tr>
							<tr><td>int</td><td>4</td><td>14-17</td><td>报文其他属性值长度</td></tr>
							<tr><td>byte</td><td></td><td></td><td>内容值</td></tr>
							<tr><td>byte</td><td></td><td></td><td>报文其他属性值</td></tr>
						</table>

		<h2>mars的序列化</h2>
				在阿里的fastJSON和google的protocol Buffer的集成上研发的一套序列化工具，目前已经开源在github上：glowworm(萤火虫):https://github.com/netcomm/glowWorm
		
		<h2>mars使用示例</h2>
		<h3>服务提供方<h3>
		<pre><code>
			  // 接口实现类
				package demo;
				import java.util.ArrayList;
				import com.cn.jd.mars.service.MarsServiceExportService;

				public class TestProducer implements TestService{
				@Override
				public String sayHello(String hiStrParm, ArrayList detailListParm) {
						//执行业务代码
						return "new world "+hiStrParm;
					}
				}
		</code></pre>
		
		<pre><code>
			  // spring配置文件
			  <?xml version="1.0" encoding="UTF-8"?>
					<beans xmlns="http://www.springframework.org/schema/beans"
							xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
							xmlns:mars="http://com.cn.360buy/schema/mars"
							xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
							http://com.cn.360buy/schema/mars http://com.cn.360buy/schema/mars/mars.xsd">
						<!-- 本地业务bean,作为服务暴露给外部 -->
						<bean id="testProducer" class="demo.TestProducer">
		    		</bean>
						<!-- 使用zookeeper作为服务注册中心 -->
						<mars:registry protocol="zookeeper" address="127.0.0.1:2181" />
						<!-- 用mars协议在10000端口暴露服务 -->
						<mars:transporServer id="mar1" type="mars" ip="127.0.0.1" port="10000" />
						<!-- 需要暴露的服务接口 -->
						<mars:service interface="demo.TestService" ref="testProducer" transporServer="mar1" />
				</beans>
		</code></pre>
		
		<h3>服务消费方<h3>
		<pre><code>
			  // 消费者例子
				package demo;

				import java.math.BigDecimal;
				import java.util.ArrayList;
				import java.util.HashMap;
				
				public class TestConsumer extends Thread
				{
					private TestService theTestService = null;
					public TestConsumer()
					{		
					}
					
					public void requestService()
					{
							ArrayList tmpList = new ArrayList();
							tmpList.add("123");
							tmpList.add(new BigDecimal("100.00"));
							HashMap tmpHMap = new HashMap();
							tmpHMap.put("1", "ok le man1");
							tmpList.add(tmpHMap);
							
							try
							{
								theTestService.sayHello("new world", tmpList);
							}
							catch(Exception ex)
							{
								ex.printStackTrace();
							}
					}
				
					public TestService getTheTestService() {
						return theTestService;
					}
				
					public void setTheTestService(TestService theTestService) {
						this.theTestService = theTestService;
					}
				}

		</code></pre>
		
		<pre><code>
			  // spring配置文件
			  <?xml version="1.0" encoding="UTF-8"?>

				<beans xmlns="http://www.springframework.org/schema/beans"
					xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
					xmlns:mars="http://com.cn.360buy/schema/mars"
					xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
					http://com.cn.360buy/schema/mars http://com.cn.360buy/schema/mars/mars.xsd">
					
					<!-- 使用zookeeper作为服务注册中心 -->
					<mars:registry protocol="zookeeper" address="127.0.0.1:2181" />
					
					<!-- 远程服务引用，可以像本地bean一样使用 -->
					<mars:serviceReference id="testService" interface="demo.TestService"
						clustertype="failover" loadbalance="roundrobin" clusterItems="" />
					
					<!-- 本地业务bean,远程服务作为属性注入 -->
					<bean id="testds" class="demo.TestConsumer">
				    	<property name="theTestService" ref="testService"/>
				  </bean>
				</beans>

		</code></pre>
		
    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Mars maintained by <a href="https://github.com/netcomm">netcomm</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>
    
    <h2>mars详细参数使用说明</h2>

  </body>
</html>
